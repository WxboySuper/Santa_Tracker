name: Deploy Santa Tracker on Release (published)

# Deploy to VPS when a GitHub Release is published.
# Uses password SSH for immediate compatibility; swap to SSH keys later.
on:
  release:
    types: [published]

permissions:
  contents: read
  actions: write

env:
  PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
  PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
  PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
  PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout release commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync util-linux

      - name: Build deployment-package
        env:
          PROD_DOTENV: ${{ secrets.PROD_DOTENV }}
        run: |
          set -euo pipefail
          mkdir -p deployment-package
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='.env' --exclude='venv/' \
            ./src/ deployment-package/src/ || true
          cp requirements.txt deployment-package/ || true
          if [ -f alembic.ini ]; then cp alembic.ini deployment-package/ || true; fi
          if [ -d alembic ]; then rsync -av --delete alembic/ deployment-package/alembic/ || true; fi

          if [ -n "${PROD_DOTENV:-}" ]; then
            printf '%s\n' "${PROD_DOTENV}" > deployment-package/.env
          else
            cat > deployment-package/.env <<EOF
# Minimal defaults; add repository secrets for production values
DATA_PATH=${PROD_DEPLOY_PATH}/data
LOG_LEVEL=INFO
EOF
          fi
          chmod 600 deployment-package/.env

      - name: Upload and finalize deploy (secure + run venv as deploy user)
        run: |
          set -euo pipefail
          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"
          TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
          REMOTE_DIR="${RELEASE_ROOT}/${TIMESTAMP}"

          echo "Creating remote release dir: ${REMOTE_DIR}"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "mkdir -p '${REMOTE_DIR}'"

          echo "Uploading files to ${REMOTE_DIR}"
          rsync -avz --delete -e "sshpass -p '${PROD_SSH_PASSWORD}' ssh -o StrictHostKeyChecking=no" \
            deployment-package/ ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST}:"${REMOTE_DIR}/"

          echo "Finalizing deploy on remote host (atomic privileged block)"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "bash -s" <<'EOF'
          set -euo pipefail
          set -x

          REMOTE_DIR="${REMOTE_DIR}"
          PROD_DEPLOY_PATH="${PROD_DEPLOY_PATH}"
          PROD_DEPLOY_USER="${PROD_DEPLOY_USER}"
          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"

          mkdir -p "${RELEASE_ROOT}"
          mkdir -p "${PROD_DEPLOY_PATH}/data" || true

          # Create venv & install requirements AS THE DEPLOY USER (not root)
          sudo -u "${PROD_DEPLOY_USER}" bash -lc "\
            python3 -m venv '${REMOTE_DIR}/venv' && \
            '${REMOTE_DIR}/venv/bin/pip' install --upgrade pip setuptools wheel; \
            if [ -f '${REMOTE_DIR}/requirements.txt' ]; then \
              '${REMOTE_DIR}/venv/bin/pip' install -r '${REMOTE_DIR}/requirements.txt'; \
            fi"

          # Run database migrations as the deploy user if present (load .env for migration env)
          if [ -f "${REMOTE_DIR}/alembic.ini" ]; then
            if [ -f "${REMOTE_DIR}/.env" ]; then
              set -o allexport; source "${REMOTE_DIR}/.env"; set +o allexport
            fi
            sudo -u "${PROD_DEPLOY_USER}" bash -lc "cd '${REMOTE_DIR}' && ./venv/bin/alembic upgrade head" || true
          fi

          # Secure uploaded .env: ensure deploy user owns it and perms are 600
          if [ -f "${REMOTE_DIR}/.env" ]; then
            sudo chown ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${REMOTE_DIR}/.env" || true
            sudo chmod 600 "${REMOTE_DIR}/.env" || true
          fi

          # If current exists and is not a symlink, move it to a backup to avoid ln putting the link inside it
          if [ -e "${PROD_DEPLOY_PATH}/current" ] && [ ! -L "${PROD_DEPLOY_PATH}/current" ]; then
            mv "${PROD_DEPLOY_PATH}/current" "${PROD_DEPLOY_PATH}/releases/previous-current-$(date +%Y%m%d-%H%M%S)" || true
          fi

          # Atomically update current to point to the new release (privileged)
          sudo ln -sfn "${REMOTE_DIR}" "${PROD_DEPLOY_PATH}/current"

          # CRITICAL: Ensure the release files and symlink are owned by the deploy user (run as root)
          sudo chown -R ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${REMOTE_DIR}" || true
          sudo chown -h ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${PROD_DEPLOY_PATH}/current" || true

          # Ensure data dir ownership
          sudo chown -R ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${PROD_DEPLOY_PATH}/data" || true

          # Cleanup older releases
          cd "${RELEASE_ROOT}" || exit 0
          ls -1dt * 2>/dev/null | tail -n +6 | xargs -r rm -rf || true

          # Reload and restart service (privileged)
          sudo systemctl daemon-reload || true
          sudo systemctl restart santa-tracker || true
          sudo systemctl status santa-tracker --no-pager || true

          echo "Deployed to ${REMOTE_DIR}"
          EOF

      - name: Post-deploy verification (runner-side)
        env:
          PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
          PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
          PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
          PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}
        run: |
          set -euo pipefail
          echo "Verifying deployment ownership and service status..."

          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "bash -s" <<'VERIFY'
          set -euo pipefail
          PROD_DEPLOY_PATH="${PROD_DEPLOY_PATH}"
          PROD_DEPLOY_USER="${PROD_DEPLOY_USER}"

          # Check ownership of current symlink and .env
          CURRENT_OWNER=$(stat -c '%U:%G' "${PROD_DEPLOY_PATH}/current" 2>/dev/null || echo "missing")
          echo "Current symlink owner: ${CURRENT_OWNER}"
          if [ "${CURRENT_OWNER}" != "${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}" ]; then
            echo "ERROR: current symlink is not owned by ${PROD_DEPLOY_USER}"
            stat -c '%U:%G %n' "${PROD_DEPLOY_PATH}/current" || true
            exit 1
          fi

          if [ -f "${PROD_DEPLOY_PATH}/current/.env" ]; then
            ENV_OWNER=$(stat -c '%U:%G %a' "${PROD_DEPLOY_PATH}/current/.env" 2>/dev/null || echo "missing")
            echo ".env: ${ENV_OWNER}"
            if ! echo "${ENV_OWNER}" | grep -q "^${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} 600$"; then
              echo "ERROR: .env ownership or permissions incorrect"
              stat -c '%U:%G %a %n' "${PROD_DEPLOY_PATH}/current/.env" || true
              exit 1
            fi
          fi

          # Check service status
          if ! sudo systemctl is-active --quiet santa-tracker; then
            echo "ERROR: santa-tracker service is not active"
            sudo systemctl status santa-tracker --no-pager || true
            sudo journalctl -u santa-tracker -n 200 --no-pager || true
            exit 1
          fi

          echo "âœ“ Deployment verification passed: ownership correct and service active"
          VERIFY
