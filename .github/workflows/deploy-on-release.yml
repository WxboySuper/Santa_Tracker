name: Deploy Santa Tracker on Release (published)

# Deploy to VPS when a GitHub Release is published.
# Uses password SSH for immediate compatibility; swap to SSH keys later.
on:
  release:
    types: [published]

permissions:
  contents: read
  actions: write

env:
  PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
  PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
  PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
  PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout release commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync util-linux

      - name: Build deployment-package
        env:
          PROD_DOTENV: ${{ secrets.PROD_DOTENV }}
        run: |
          set -euo pipefail
          mkdir -p deployment-package
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='.env' --exclude='venv/' \
            ./src/ deployment-package/src/ || true
          cp requirements.txt deployment-package/ || true
          if [ -f alembic.ini ]; then cp alembic.ini deployment-package/ || true; fi
          if [ -d alembic ]; then rsync -av --delete alembic/ deployment-package/alembic/ || true; fi
          if [ -n "${PROD_DOTENV:-}" ]; then
            printf '%s\n' "${PROD_DOTENV}" > deployment-package/.env
          else
            cat > deployment-package/.env <<EOF
          # Minimal defaults; add repository secrets for production values
          DATA_PATH=${PROD_DEPLOY_PATH}/data
          LOG_LEVEL=INFO
          EOF
          fi
          chmod 600 deployment-package/.env

      - name: Upload and finalize deploy
        run: |
          set -euo pipefail
          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"
          TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
          REMOTE_DIR="${RELEASE_ROOT}/${TIMESTAMP}"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "mkdir -p '${REMOTE_DIR}'"
          rsync -avz --delete -e "sshpass -p '${PROD_SSH_PASSWORD}' ssh -o StrictHostKeyChecking=no" \
            deployment-package/ ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST}:"${REMOTE_DIR}/"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "bash -s" <<EOF
          set -euo pipefail
          REMOTE_DIR="${REMOTE_DIR}"
          PROD_DEPLOY_PATH="${PROD_DEPLOY_PATH}"
          PROD_DEPLOY_USER="${PROD_DEPLOY_USER}"
          # create venv & install as the deploy user (not root)
          sudo -u "\${PROD_DEPLOY_USER}" bash -lc "
            python3 -m venv '${REMOTE_DIR}/venv' && \
            '${REMOTE_DIR}/venv/bin/pip' install --upgrade pip setuptools wheel && \
            if [ -f '${REMOTE_DIR}/requirements.txt' ]; then \
              '${REMOTE_DIR}/venv/bin/pip' install -r '${REMOTE_DIR}/requirements.txt'; \
            fi
          "
          # Run migrations as deploy user if needed
          if [ -f "${REMOTE_DIR}/alembic.ini" ]; then
            if [ -f "${REMOTE_DIR}/.env" ]; then
              set -o allexport; source "${REMOTE_DIR}/.env"; set +o allexport
            fi
            # Allow migration failures to not block deployment (matches original behavior)
            sudo -u "\${PROD_DEPLOY_USER}" bash -lc "cd '${REMOTE_DIR}' && './venv/bin/alembic' upgrade head" || true
          fi
          # Switch symlink (privileged operation)
          sudo ln -sfn "${REMOTE_DIR}" "${PROD_DEPLOY_PATH}/current"
          # Ensure the release files and symlink are owned by the deploy user
          sudo chown -R "\${PROD_DEPLOY_USER}:\${PROD_DEPLOY_USER}" "${REMOTE_DIR}" || true
          sudo chown -h "\${PROD_DEPLOY_USER}:\${PROD_DEPLOY_USER}" "${PROD_DEPLOY_PATH}/current" || true
          # (Optional) fix perms on data dir
          sudo chown -R "\${PROD_DEPLOY_USER}:\${PROD_DEPLOY_USER}" "${PROD_DEPLOY_PATH}/data" || true
          # Reload and restart service
          sudo systemctl daemon-reload || true
          sudo systemctl restart santa-tracker || true
          systemctl status santa-tracker --no-pager || true
          EOF

      - name: Post-deploy verification
        env:
          PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
          PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
          PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
          PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}
        run: |
          set -euo pipefail
          echo "Verifying deployment ownership and service status..."
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "PROD_DEPLOY_PATH='${PROD_DEPLOY_PATH}' PROD_DEPLOY_USER='${PROD_DEPLOY_USER}' \
            bash -s" <<'VERIFY_EOF'
          set -euo pipefail
          PROD_DEPLOY_PATH="${PROD_DEPLOY_PATH}"
          PROD_DEPLOY_USER="${PROD_DEPLOY_USER}"
          
          # Check ownership of current symlink
          CURRENT_OWNER=$(stat -c '%U:%G' "${PROD_DEPLOY_PATH}/current" 2>/dev/null || echo "missing")
          echo "Current symlink owner: ${CURRENT_OWNER}"
          if [ "${CURRENT_OWNER}" != "${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}" ]; then
            echo "ERROR: current symlink is not owned by ${PROD_DEPLOY_USER}"
            stat -c '%U:%G %n' "${PROD_DEPLOY_PATH}/current" || true
            exit 1
          fi
          
          # Check service status
          if ! sudo systemctl is-active --quiet santa-tracker; then
            echo "ERROR: santa-tracker service is not active"
            sudo systemctl status santa-tracker --no-pager || true
            sudo journalctl -u santa-tracker -n 200 --no-pager || true
            exit 1
          fi
          
          echo "âœ“ Deployment verification passed: ownership correct and service active"
          VERIFY_EOF
