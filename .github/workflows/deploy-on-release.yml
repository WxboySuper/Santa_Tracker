name: Deploy Santa Tracker on Release (published)

# Deploy to VPS when a GitHub Release is published.
# Uses password SSH for immediate compatibility; swap to SSH keys later.
on:
  release:
    types: [published]

permissions:
  contents: read
  actions: write

env:
  PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
  PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
  PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
  PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout release commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync util-linux

      - name: Build deployment-package
        env:
          PROD_DOTENV: ${{ secrets.PROD_DOTENV }}
        run: |
          set -euo pipefail
          mkdir -p deployment-package
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='.env' --exclude='venv/' \
            ./src/ deployment-package/src/ || true
          cp requirements.txt deployment-package/ || true
          if [ -f alembic.ini ]; then cp alembic.ini deployment-package/ || true; fi
          if [ -d alembic ]; then rsync -av --delete alembic/ deployment-package/alembic/ || true; fi

          if [ -n "${PROD_DOTENV:-}" ]; then
            printf '%s\n' "${PROD_DOTENV}" > deployment-package/.env
          else
            # write .env without using an indented heredoc to avoid YAML here-doc pitfalls
            printf '%s\n' "DATA_PATH=${PROD_DEPLOY_PATH}/data" "LOG_LEVEL=INFO" > deployment-package/.env
          fi
          chmod 600 deployment-package/.env

      - name: Upload and finalize deploy (secure + run venv as deploy user)
        run: |
          set -euo pipefail

          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"
          TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
          REMOTE_DIR="${RELEASE_ROOT}/${TIMESTAMP}"

          echo "Creating remote release dir: ${REMOTE_DIR}"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "mkdir -p '${REMOTE_DIR}'"

          echo "Uploading files to ${REMOTE_DIR}"
          rsync -avz --delete -e "sshpass -p '${PROD_SSH_PASSWORD}' ssh -o StrictHostKeyChecking=no" \
            deployment-package/ ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST}:"${REMOTE_DIR}/"

          echo "Finalizing deploy on remote host (atomic privileged block)"
          # pass concrete values on the ssh command line; remote script provided via indented here-doc
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "PROD_DEPLOY_PATH='${PROD_DEPLOY_PATH}' PROD_DEPLOY_USER='${PROD_DEPLOY_USER}' REMOTE_DIR='${REMOTE_DIR}' bash -s" <<'REMOTE_EOF'
            set -euo pipefail
            set -x

            # Remote variables available: $REMOTE_DIR, $PROD_DEPLOY_PATH, $PROD_DEPLOY_USER
            RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"

            mkdir -p "${RELEASE_ROOT}"
            mkdir -p "${PROD_DEPLOY_PATH}/data" || true

            # Create venv & install requirements AS THE DEPLOY USER (not root)
            sudo -u "${PROD_DEPLOY_USER}" bash -lc "\
              python3 -m venv '${REMOTE_DIR}/venv' && \
              '${REMOTE_DIR}/venv/bin/pip' install --upgrade pip setuptools wheel || true; \
              if [ -f '${REMOTE_DIR}/requirements.txt' ]; then \
                '${REMOTE_DIR}/venv/bin/pip' install -r '${REMOTE_DIR}/requirements.txt' || true; \
              fi"

            # Run database migrations as the deploy user if present (load .env for migration env)
            if [ -f "${REMOTE_DIR}/alembic.ini" ]; then
              if [ -f "${REMOTE_DIR}/.env" ]; then
                set -o allexport; source "${REMOTE_DIR}/.env"; set +o allexport
              fi
              sudo -u "${PROD_DEPLOY_USER}" bash -lc "cd '${REMOTE_DIR}' && ./venv/bin/alembic upgrade head" || true
            fi

            # Secure uploaded .env: ensure deploy user owns it and perms are 600
            if [ -f "${REMOTE_DIR}/.env" ]; then
              sudo chown "${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}" "${REMOTE_DIR}/.env" || true
              sudo chmod 600 "${REMOTE_DIR}/.env" || true
            fi

            # If current exists and is not a symlink, move it to a backup to avoid ln putting the link inside it
            if [ -e "${PROD_DEPLOY_PATH}/current" ] && [ ! -L "${PROD_DEPLOY_PATH}/current" ]; then
              mv "${PROD_DEPLOY_PATH}/current" "${PROD_DEPLOY_PATH}/releases/previous-current-$(date +%Y%m%d-%H%M%S)" || true
            fi

            # Atomically update current to point to the new release (privileged)
            sudo ln -sfn "${REMOTE_DIR}" "${PROD_DEPLOY_PATH}/current"

            # CRITICAL: Ensure the release files and symlink are owned by the deploy user (run as root)
            sudo chown -R "${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}" "${REMOTE_DIR}" || true
            sudo chown -h "${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}" "${PROD_DEPLOY_PATH}/current" || true

            # Ensure data dir ownership
            sudo chown -R "${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}" "${PROD_DEPLOY_PATH}/data" || true

            # Cleanup older releases (keep 5)
            cd "${RELEASE_ROOT}" || exit 0
            ls -1dt * 2>/dev/null | tail -n +6 | xargs -r rm -rf || true

            # Reload and restart service (privileged)
            sudo systemctl daemon-reload || true
            sudo systemctl restart santa-tracker || true
            sudo systemctl status santa-tracker --no-pager || true

            echo "Deployed to ${REMOTE_DIR}"
          REMOTE_EOF

      - name: Post-deploy verification (runner-side)
        env:
          PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
          PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
          PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
          PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}
        run: |
          set -euo pipefail
          echo "Verifying deployment ownership and service status..."

          # Provide expected values on the ssh command line; verification runs remotely
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "PROD_DEPLOY_PATH='${PROD_DEPLOY_PATH}' PROD_DEPLOY_USER='${PROD_DEPLOY_USER}' bash -s" <<'VERIFY_EOF'
            set -euo pipefail

            # Remote variables: $PROD_DEPLOY_PATH, $PROD_DEPLOY_USER

            CURRENT_OWNER=$(stat -c '%U:%G' "${PROD_DEPLOY_PATH}/current" 2>/dev/null || echo "missing")
            echo "Current symlink owner: ${CURRENT_OWNER}"

            EXPECTED_OWNER="${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER}"
            # Note: GitHub masks secrets in logs; EXPECTED_OWNER will appear masked in Action logs.

            if [ "${CURRENT_OWNER}" != "${EXPECTED_OWNER}" ]; then
              echo "ERROR: current symlink is not owned by ${EXPECTED_OWNER}"
              echo "--- Diagnostics ---"
              echo "Target of current symlink:"
              readlink -f "${PROD_DEPLOY_PATH}/current" || true
              echo ""
              echo "Owner and mode of current symlink (and target if available):"
              stat -c '%U:%G %a %n' "${PROD_DEPLOY_PATH}/current" 2>/dev/null || true
              echo ""
              echo "Listing release dir and current contents:"
              ls -la "${PROD_DEPLOY_PATH}" || true
              ls -la "$(readlink -f "${PROD_DEPLOY_PATH}/current")" || true
              echo ""
              echo ".env owner/perms (if present):"
              stat -c '%U:%G %a %n' "${PROD_DEPLOY_PATH}/current/.env" 2>/dev/null || true
              echo ""
              echo "Systemd status (last 100 lines):"
              sudo journalctl -u santa-tracker -n 100 --no-pager || true
              echo ""
              echo "Likely causes:"
              echo " - The repository secret PROD_DEPLOY_USER does not match the system user that should own the release (e.g. 'santa')."
              echo " - The deploy finalize chown failed or did not run as root."
              echo ""
              echo "Quick fixes (run on the server):"
              echo " sudo chown -R ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} ${PROD_DEPLOY_PATH}/releases/<release>"
              echo " sudo chown -h ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} ${PROD_DEPLOY_PATH}/current"
              echo ""
              echo "If the secret is wrong, update the repository secret PROD_DEPLOY_USER to the actual deploy user (e.g. 'santa')."
              exit 1
            fi

            if [ -f "${PROD_DEPLOY_PATH}/current/.env" ]; then
              ENV_OWNER_PERMS=$(stat -c '%U:%G %a' "${PROD_DEPLOY_PATH}/current/.env" 2>/dev/null || echo "missing")
              echo ".env: ${ENV_OWNER_PERMS}"
              if ! echo "${ENV_OWNER_PERMS}" | grep -q "^${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} 6"; then
                echo "ERROR: .env ownership or permissions incorrect (expected ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} 600)"
                stat -c '%U:%G %a %n' "${PROD_DEPLOY_PATH}/current/.env" || true
                exit 1
              fi
            fi

            if ! sudo systemctl is-active --quiet santa-tracker; then
              echo "ERROR: santa-tracker service is not active"
              sudo systemctl status santa-tracker --no-pager || true
              sudo journalctl -u santa-tracker -n 200 --no-pager || true
              exit 1
            fi

            echo "âœ“ Deployment verification passed: ownership correct and service active"
          VERIFY_EOF
